<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kaptanın Spotify</title>

<style>

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: Arial, sans-serif;
}

body {
  background: #000;
  color: white;
  display: flex;
  height: 100vh;
  overflow: hidden;
}

/* ------------------------- */
/*        SIDEBAR            */
/* ------------------------- */

.sidebar {
  width: 240px;
  background: #000;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 25px;
  border-right: 1px solid #111;
}

.sidebar h1 {
  font-size: 24px;
  font-weight: bold;
  color: #1DB954;
}

.sidebar a {
  color: #ddd;
  text-decoration: none;
  font-size: 16px;
  padding: 8px 0;
  transition: .2s;
}

.sidebar a:hover {
  color: white;
}

/* ------------------------- */
/*     MAIN CONTENT          */
/* ------------------------- */

.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, #222 0%, #000 40%);
  overflow: hidden;
}

.header {
  padding: 20px;
  font-size: 26px;
  font-weight: bold;
}

.search-box {
  margin: 0 20px;
}

.search-box input {
  width: 100%;
  padding: 14px;
  border-radius: 8px;
  background: #111;
  border: 1px solid #333;
  color: white;
  font-size: 16px;
}

/* ------------------------- */
/*       SEARCH RESULTS      */
/* ------------------------- */

.results {
  margin-top: 20px;
  padding: 0 20px;
  height: 260px;
  overflow-y: auto;
}

.result-item {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: .2s;
  background: #111;
}

.result-item:hover {
  background: #181818;
}

.result-item img {
  width: 65px;
  height: 65px;
  border-radius: 6px;
}

.result-title {
  font-size: 17px;
  font-weight: bold;
}

/* ------------------------- */
/*       PLAYLIST AREA       */
/* ------------------------- */

.playlist {
  padding: 20px;
  flex: 1;
  overflow-y: auto;
}

.playlist h2 {
  margin-bottom: 12px;
  font-size: 22px;
}

.song-item {
  background: #111;
  padding: 12px;
  border-radius: 8px;
  display: flex;
  gap: 15px;
  align-items: center;
  margin-bottom: 10px;
  cursor: pointer;
  transition: .2s;
}

.song-item:hover {
  background: #181818;
}

.song-item img {
  width: 60px;
  height: 60px;
  border-radius: 6px;
}

.song-info {
  display: flex;
  flex-direction: column;
}

.song-info .title {
  font-size: 16px;
  font-weight: bold;
}

.song-info .author {
  font-size: 14px;
  opacity: .7;
}

/* ------------------------- */
/*        PLAYER BAR         */
/* ------------------------- */

.player-bar {
  height: 110px;
  background: #111;
  border-top: 1px solid #222;
  display: flex;
  align-items: center;
  padding: 15px;
  gap: 20px;
}

.player-thumb {
  width: 75px;
  height: 75px;
  border-radius: 6px;
  background: #222;
}

.player-info {
  flex: 1;
}

.player-info .title {
  font-size: 18px;
  font-weight: bold;
}

.player-info .author {
  font-size: 14px;
  opacity: .7;
}

.controls {
  display: flex;
  gap: 20px;
}

.controls button {
  background: none;
  border: none;
  color: white;
  font-size: 28px;
  cursor: pointer;
}

.controls button:hover {
  color: #1DB954;
}

/* ------------------------- */
/* EMBED (GİZLİ PLAYER)      */
/* ------------------------- */

#yt-player {
  width: 0;
  height: 0;
  visibility: hidden;
}

/* ------------------------- */
/* SCROLL BAR                */
/* ------------------------- */

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 10px;
}

</style>
</head>
<body>

<!-- ----------------------------- -->
<!--          SIDEBAR              -->
<!-- ----------------------------- -->

<div class="sidebar">
  <h1>Kaptanify</h1>
  <a href="#">Ana Sayfa</a>
  <a href="#">Keşfet</a>
  <a href="#">Listem</a>
  <a href="#">Ayarlar</a>
</div>

<!-- ----------------------------- -->
<!--           MAIN                -->
<!-- ----------------------------- -->

<div class="main">

  <div class="header">Müzik Keşfet</div>

  <div class="search-box">
    <input id="searchInput" type="text" placeholder="Şarkı veya sanatçı ara…">
  </div>

  <div class="results" id="results"></div>

  <div class="playlist">
    <h2>Çalma Listem</h2>
    <div id="playlist"></div>
  </div>

</div>

<!-- ----------------------------- -->
<!--         PLAYER BAR            -->
<!-- ----------------------------- -->

<div class="player-bar">
  <img id="playerThumb" class="player-thumb" src="">
  <div class="player-info">
    <div class="title" id="playerTitle">Şarkı Seçilmedi</div>
    <div class="author" id="playerAuthor"></div>
  </div>

  <div class="controls">
    <button id="prevBtn">⏮</button>
    <button id="playBtn">▶</button>
    <button id="nextBtn">⏭</button>
  </div>
</div>

<!-- GİZLİ PLAYER -->
<iframe id="yt-player" src=""></iframe>

<!-- JS BURAYA GELECEK (PART 2) -->

</body>
</html>
<script>
/* ============================
   PART 2 - YOUTUBE + PLAYER
   ============================
   Paste this under PART 1 (where indicated).
   Replace YOUR_API_KEY with your actual key.
*/

/* -------- CONFIG ---------- */
const API_KEY = "AIzaSyAFmms_JJrVmmv-rPP4INamToX9xmuVyJY"; // ← buraya koy
const MAX_RESULTS = 20;
const PREVIEW_SECONDS = 7; // preview uzunluğu
const PREVIEW_MIN_START = 5; // preview başlama için minimum saniye
const PREVIEW_MAX_START = 40; // preview için rastgele aralık sonu

/* -------- DOM refs --------- */
const resultsEl = document.getElementById("results");
const playlistEl = document.getElementById("playlist");
const searchInput = document.getElementById("searchInput");
const playerThumb = document.getElementById("playerThumb");
const playerTitle = document.getElementById("playerTitle");
const playerAuthor = document.getElementById("playerAuthor");
const playBtn = document.getElementById("playBtn");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const progressFill = document.getElementById("progressFill");
const playerBar = document.getElementById("playerBar");

/* -------- state ---------- */
let ytPlayerMain = null;     // main YT player (hidden)
let previewPlayer = null;    // preview YT player instance
let previewHost = null;      // DOM node for preview
let searchResults = [];      // current search results (API response)
let playlist = [];           // queue (objects: {videoId,title,thumb,channel})
let currentIndex = -1;       // index in searchResults if playing from results
let isPlaying = false;
let progressTimer = null;

/* ---------- UTILS ---------- */
function formatTime(seconds) {
  seconds = Math.max(0, Math.floor(seconds || 0));
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s.toString().padStart(2,"0")}`;
}

/* ---------- YT IFRAME API READY ---------- */
/* We'll create a hidden div for the main YT player to avoid iframe origin problems. */
function onYouTubeIframeAPIReady() {
  // create a host for main player
  const host = document.createElement("div");
  host.id = "yt-main-host";
  host.style.width = "0";
  host.style.height = "0";
  host.style.position = "absolute";
  host.style.left = "-9999px";
  document.body.appendChild(host);

  ytPlayerMain = new YT.Player(host, {
    height: "0",
    width: "0",
    videoId: "",
    playerVars: {
      autoplay: 0,
      controls: 0,
      modestbranding: 1,
      rel: 0,
      playsinline: 1,
      disablekb: 1,
      fs: 0
    },
    events: {
      onStateChange: onMainStateChange,
      onReady: () => { /* ready */ }
    }
  });
}

/* ---------- MAIN PLAYER STATE HANDLER ---------- */
function onMainStateChange(e) {
  if (!ytPlayerMain) return;
  const state = e.data;
  const eq = document.getElementById("eqAnim");
  if (state === YT.PlayerState.PLAYING) {
    isPlaying = true;
    playBtn.innerText = "⏸";
    if (eq) eq.style.display = "inline-flex";
    startProgressTicker();
  } else if (state === YT.PlayerState.PAUSED || state === YT.PlayerState.BUFFERING) {
    isPlaying = false;
    playBtn.innerText = "▶";
    if (eq) eq.style.display = "none";
    stopProgressTicker();
  } else if (state === YT.PlayerState.ENDED) {
    // track ended -> autoplay next
    nextTrack();
  }
}

/* ---------- PROGRESS TICKER ---------- */
function startProgressTicker(){
  stopProgressTicker();
  progressTimer = setInterval(()=>{
    try {
      const cur = ytPlayerMain.getCurrentTime();
      const dur = ytPlayerMain.getDuration() || 0;
      const pct = dur ? Math.min(100, (cur/dur)*100) : 0;
      progressFill.style.width = pct + "%";
    } catch(e){}
  }, 350);
}
function stopProgressTicker(){ if(progressTimer){ clearInterval(progressTimer); progressTimer=null; }}

/* ---------- YOUTUBE SEARCH (Data API v3) ---------- */
async function ytSearch(q) {
  if (!q) return [];
  const endpoint = "https://www.googleapis.com/youtube/v3/search";
  const params = new URLSearchParams({
    part: "snippet",
    q,
    type: "video",
    maxResults: String(MAX_RESULTS),
    key: API_KEY,
    videoCategoryId: "10"
  });
  try {
    const res = await fetch(`${endpoint}?${params.toString()}`);
    if (!res.ok) {
      console.error("YT search failed:", res.status);
      return [];
    }
    const j = await res.json();
    return j.items || [];
  } catch (err) {
    console.error("YT search error", err);
    return [];
  }
}

/* ---------- RENDER RESULTS ---------- */
function renderResults(items) {
  searchResults = items;
  resultsEl.innerHTML = "";
  items.forEach((it, idx) => {
    const vid = it.id.videoId;
    const title = it.snippet.title;
    const ch = it.snippet.channelTitle;
    const thumb = (it.snippet.thumbnails && (it.snippet.thumbnails.medium?.url || it.snippet.thumbnails.default?.url)) || "";

    const card = document.createElement("div");
    card.className = "result-item";
    card.dataset.index = idx;
    card.innerHTML = `
      <img src="${thumb}" alt="thumb">
      <div style="flex:1">
        <div class="result-title">${title}</div>
        <div class="channel">${ch}</div>
      </div>
      <button title="Ekle" class="plusBtn" style="background:#1DB954;border:none;padding:8px;border-radius:8px;margin-left:8px;cursor:pointer">+</button>
    `;

    // hover preview
    card.addEventListener("mouseenter", (e) => {
      startPreview(vid, card);
    });
    card.addEventListener("mouseleave", stopPreview);

    // click -> play
    card.addEventListener("click", (e) => {
      if (e.target && e.target.closest(".plusBtn")) return; // skip if clicked plus
      playFromResults(idx);
    });

    // plus button -> add to playlist
    const plus = card.querySelector(".plusBtn");
    plus.addEventListener("click", (ev) => {
      ev.stopPropagation();
      addToPlaylist({ videoId: vid, title, thumb, channel: ch });
    });

    resultsEl.appendChild(card);
  });
}

/* ---------- PREVIEW (single ephemeral player) ---------- */
function startPreview(videoId, cardElement) {
  stopPreview(); // ensure only one preview
  previewHost = document.createElement("div");
  previewHost.style.position = "absolute";
  previewHost.style.left = "8px";
  previewHost.style.top = "8px";
  previewHost.style.width = "calc(100% - 16px)";
  previewHost.style.height = "112px";
  previewHost.style.borderRadius = "8px";
  previewHost.style.overflow = "hidden";
  previewHost.style.zIndex = 30;
  previewHost.style.background = "#000";
  // ensure cardElement position is relative
  cardElement.style.position = "relative";
  cardElement.appendChild(previewHost);

  // preview container
  const previewDiv = document.createElement("div");
  previewDiv.id = "preview-" + Date.now();
  previewDiv.style.width = "100%";
  previewDiv.style.height = "100%";
  previewHost.appendChild(previewDiv);

  // random start sec
  const start = Math.floor(Math.random() * Math.max(1, PREVIEW_MAX_START - PREVIEW_MIN_START)) + PREVIEW_MIN_START;
  const end = start + PREVIEW_SECONDS;

  // create preview YT player
  try {
    previewPlayer = new YT.Player(previewDiv, {
      height: "100%",
      width: "100%",
      videoId: videoId,
      playerVars: {
        autoplay: 1,
        controls: 0,
        start,
        end,
        mute: 1,
        modestbranding: 1,
        playsinline: 1,
        rel: 0
      },
      events: {
        onReady: (e) => { try{ e.target.playVideo(); }catch(e){} },
        onStateChange: (s) => {
          if (s.data === YT.PlayerState.ENDED) {
            try { previewPlayer.seekTo(start); previewPlayer.playVideo(); } catch(e){}
          }
        }
      }
    });
  } catch(e) {
    console.error("preview create failed", e);
  }
}
function stopPreview() {
  try { if (previewPlayer && previewPlayer.destroy) previewPlayer.destroy(); } catch(e){}
  previewPlayer = null;
  try { if (previewHost && previewHost.parentNode) previewHost.parentNode.removeChild(previewHost); } catch(e){}
  previewHost = null;
}

/* ---------- PLAYLIST ---------- */
function addToPlaylist(item) {
  playlist.push(item);
  renderPlaylist();
}
function renderPlaylist(){
  playlistEl.innerHTML = "";
  playlist.forEach((p, i) => {
    const el = document.createElement("div");
    el.className = "playlistItem";
    el.innerHTML = `<img src="${p.thumb}"><div class="playlistMeta">${p.title}</div>`;
    el.addEventListener("click", ()=> { playFromPlaylist(i); });
    playlistEl.appendChild(el);
  });
}

/* ---------- PLAY HANDLERS ---------- */
function playFromResults(idx) {
  const it = searchResults[idx];
  if (!it) return;
  const obj = {
    videoId: it.id.videoId,
    title: it.snippet.title,
    thumb: (it.snippet.thumbnails && (it.snippet.thumbnails.medium?.url || it.snippet.thumbnails.default?.url)) || '',
    channel: it.snippet.channelTitle
  };
  // set currentIndex relative to search results
  currentIndex = idx;
  startMainPlayback(obj);
}

function playFromPlaylist(idx) {
  const p = playlist[idx];
  if (!p) return;
  // when playing from playlist, currentIndex = -1 (not in searchResults)
  currentIndex = -1;
  startMainPlayback(p);
}

/* ---------- START MAIN PLAYBACK ---------- */
function startMainPlayback(item) {
  // show bar
  playerBar.style.display = "flex";
  playerThumb.src = item.thumb || "";
  playerTitle.innerText = item.title || "";
  playerAuthor.innerText = item.channel || "";

  // load into hidden main player
  if (ytPlayerMain && ytPlayerMain.loadVideoById) {
    try {
      ytPlayerMain.loadVideoById({ videoId: item.videoId, startSeconds: 0 });
      ytPlayerMain.playVideo();
    } catch (err) {
      // sometimes loadVideoById expects string
      try { ytPlayerMain.loadVideoById(item.videoId); ytPlayerMain.playVideo(); } catch(e){ console.error(e); }
    }
  } else {
    // fallback retry
    setTimeout(()=> startMainPlayback(item), 300);
  }
}

/* ---------- CONTROLS ---------- */
playBtn.addEventListener("click", ()=> {
  if (!ytPlayerMain) return;
  const st = ytPlayerMain.getPlayerState();
  if (st === YT.PlayerState.PLAYING) ytPlayerMain.pauseVideo();
  else ytPlayerMain.playVideo();
});
nextBtn.addEventListener("click", nextTrack);
prevBtn.addEventListener("click", prevTrack);

function nextTrack(){
  if (playlist.length > 0) {
    // if playing from playlist, advance
    if (currentIndex === -1) {
      // find currently playing index in playlist
      // We'll keep a pointer: currentIndexPlaylist stored in playlistPlayIndex
      if (typeof playlistPlayIndex === "undefined") playlistPlayIndex = 0;
      playlistPlayIndex = (playlistPlayIndex + 1) % playlist.length;
      playFromPlaylist(playlistPlayIndex);
    } else {
      // playing from results -> go to next result
      if (currentIndex < searchResults.length - 1) playFromResults(currentIndex + 1);
    }
  } else {
    // no playlist -> just move within results
    if (currentIndex >= 0 && currentIndex < searchResults.length - 1) {
      playFromResults(currentIndex + 1);
    }
  }
}
function prevTrack(){
  if (playlist.length > 0) {
    if (typeof playlistPlayIndex === "undefined") playlistPlayIndex = 0;
    playlistPlayIndex = (playlistPlayIndex - 1 + playlist.length) % playlist.length;
    playFromPlaylist(playlistPlayIndex);
  } else {
    if (currentIndex > 0) playFromResults(currentIndex - 1);
  }
}

/* ---------- SEARCH HANDLERS (throttled suggestions) ---------- */
let suggestionTimeout = null;
searchInput.addEventListener("input", (e) => {
  const q = searchInput.value.trim();
  if (suggestionTimeout) clearTimeout(suggestionTimeout);
  suggestionTimeout = setTimeout(async () => {
    if (!q) { resultsEl.innerHTML = ""; return; }
    const data = await ytSearch(q);
    // show top 8 as immediate results
    renderResults(data.slice(0, 8));
  }, 260);
});
searchInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    const q = searchInput.value.trim();
    if (!q) return;
    // load more results and render (full)
    (async ()=> {
      const data = await ytSearch(q);
      renderResults(data);
    })();
  }
});

/* ---------- Clicking outside preview hides suggestion box (if any) ---------- */
document.addEventListener("click", (e)=>{
  // nothing special here in PART2, handled by cards
});

/* ---------- INITIAL DEMO POPULATE ---------- */
(async function init(){
  // small warm search to populate UI
  const demo = await ytSearch("pop music");
  renderResults(demo.slice(0,12));
})();

/* ---------- CLEANUP on unload ---------- */
window.addEventListener("unload", () => {
  try { if (ytPlayerMain && ytPlayerMain.destroy) ytPlayerMain.destroy(); } catch(e){}
  try { if (previewPlayer && previewPlayer.destroy) previewPlayer.destroy(); } catch(e){}
});

</script>
